import copy
import time
from typing import Dict, List

def optimized_backtracking_planner(salary: float, categories: Dict[str, Dict[str, float]], 
                                 fixed_assignments: Dict[str, float], priorities: Dict[str, float], 
                                 tuple_data: List[Dict[str, float]]) -> Dict[str, float]:
    """
    Complete CSP-based budget planner with:
    - MRV heuristic for variable selection
    - LCV heuristic for value ordering
    - Special handling for savings
    - Fixed assignment support
    """
    
    # Include all relevant categories
    all_categories = list(set(categories.keys()).union(set(fixed_assignments.keys())))
    
    # Build domains with flexible values
    domains = {}
    for category in all_categories:
        if category in fixed_assignments:
            domains[category] = [fixed_assignments[category]]
        else:
            # Get values from tuples plus min/max
            values = [t[category] for t in tuple_data if category in t]
            values.extend([categories[category]['min'], categories[category]['max']])
            domains[category] = sorted(list(set(values)))
    
    # Initialize assignments
    assignments = fixed_assignments.copy()

    # Heuristic Functions
    def select_unassigned_variable(assignments, domains):
        """MRV heuristic with priority tie-breaker"""
        unassigned = [var for var in domains if var not in assignments]
        return min(unassigned, key=lambda var: (len(domains[var]), -priorities.get(var, 0)))

    def order_domain_values(var, assignments):
        """LCV heuristic with special savings handling"""
        remaining = salary - sum(assignments.values())
        
        if var == 'savings':
            # For savings, try values closest to remaining amount first
            return sorted(domains[var], key=lambda x: abs(x - remaining))
        
        # For other variables, try values based on priority
        return sorted(domains[var], key=lambda val: priorities.get(var, 0))

    # Consistency Check
    def is_consistent(var, value, assignments):
        temp_assign = assignments.copy()
        temp_assign[var] = value
        
        # Check fixed assignments
        for fixed in fixed_assignments:
            if temp_assign.get(fixed) != fixed_assignments[fixed]:
                return False
        
        current_total = sum(temp_assign.values())
        
        # Complete assignment check
        if len(temp_assign) == len(domains):
            return abs(current_total - salary) < 0.01
        
        # Partial assignment check
        remaining_vars = [v for v in domains if v not in temp_assign]
        remaining_min = sum(domains[v][0] for v in remaining_vars)
        remaining_max = sum(domains[v][-1] for v in remaining_vars)
        
        return (current_total + remaining_min <= salary and 
                current_total + remaining_max >= salary)

    # Backtracking with Timeout
    start_time = time.time()
    max_time = 30  # seconds
    
    def backtrack(assignments):
        if time.time() - start_time > max_time:
            raise TimeoutError()
            
        if len(assignments) == len(domains):
            return assignments
            
        var = select_unassigned_variable(assignments, domains)
        for value in order_domain_values(var, assignments):
            if is_consistent(var, value, assignments):
                assignments[var] = value
                result = backtrack(assignments.copy())
                if result:
                    return result
                del assignments[var]
        return None

    try:
        solution = backtrack(assignments)
        if solution and abs(sum(solution.values()) - salary) < 0.01:
            return solution
    except TimeoutError:
        print("Timeout reached")
    
    return None
